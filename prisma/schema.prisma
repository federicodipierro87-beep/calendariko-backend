generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  ARTIST
}

enum EventStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum NotificationType {
  INFO
  WARNING
  SUCCESS
  ERROR
}

model User {
  id                          String    @id @default(cuid())
  email                       String    @unique
  passwordHash                String
  firstName                   String
  lastName                    String
  role                        Role      @default(USER)
  emailVerified               Boolean   @default(false)
  verificationToken           String?   @unique
  verificationTokenExpiresAt  DateTime?
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt

  // Relazioni
  events              Event[]
  groupMemberships    UserGroup[]
  availabilities      Availability[]
  dayAvailabilities   DayAvailability[] @relation("UserDayAvailability")
  notifications       Notification[]
  createdGroups       Group[]         @relation("GroupCreator")
  auditLogs           AuditLog[]

  @@map("users")
}

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  type        String?  // BAND, DJ, SOLO, etc.
  color       String?
  creatorId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relazioni
  creator     User        @relation("GroupCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  members     UserGroup[]
  events      Event[]
  dayAvailabilities DayAvailability[] @relation("GroupDayAvailability")

  @@map("groups")
}

model UserGroup {
  id      String @id @default(cuid())
  userId  String
  groupId String

  // Relazioni
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("user_groups")
}

model Event {
  id                   String      @id @default(cuid())
  title                String
  description          String?
  startTime            DateTime
  endTime              DateTime
  location             String?
  status               EventStatus @default(PENDING)
  userId               String
  groupId              String?
  fee                  Int?        // Cachet dell'evento (in euro, senza decimali)
  contact_responsible  String?     // Contatto responsabile dell'evento
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  // Relazioni
  user                 User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  group                Group?      @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@map("events")
}

model Availability {
  id        String   @id @default(cuid())
  userId    String
  dayOfWeek Int      // 0 = Domenica, 1 = Lunedì, etc.
  startTime String   // Format: "HH:mm"
  endTime   String   // Format: "HH:mm"
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relazioni
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("availability")
}

model DayAvailability {
  id        String   @id @default(cuid())
  userId    String?  // Opzionale per le indisponibilità di gruppo
  groupId   String?  // Per le indisponibilità di gruppo
  date      DateTime // Data specifica (es. 2025-12-05)
  type      String   // BUSY, AVAILABLE
  notes     String?  // Note opzionali
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relazioni
  user      User?    @relation("UserDayAvailability", fields: [userId], references: [id], onDelete: Cascade)
  group     Group?   @relation("GroupDayAvailability", fields: [groupId], references: [id], onDelete: Cascade)

  @@map("day_availability")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  title     String
  message   String
  type      NotificationType @default(INFO)
  data      Json?            // Campo per dati aggiuntivi (es. newUserId per registrazioni)
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relazioni
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model AuditLog {
  id          String    @id @default(cuid())
  action      String    // es: CREATE_USER, UPDATE_USER, DELETE_USER, CREATE_GROUP, etc.
  entity      String    // es: USER, GROUP, EVENT, AVAILABILITY
  entityId    String?   // ID dell'entità modificata
  adminId     String    // ID dell'admin che ha eseguito l'azione
  admin       User      @relation(fields: [adminId], references: [id], onDelete: Cascade)
  details     Json?     // Dettagli dell'azione (prima/dopo, parametri, etc.)
  ipAddress   String?   // IP da cui è stata eseguita l'azione
  userAgent   String?   // User agent del browser
  success     Boolean   @default(true)  // Se l'azione è stata completata con successo
  errorMessage String?  // Messaggio di errore se success = false
  createdAt   DateTime  @default(now())
  
  @@index([adminId])
  @@index([action])
  @@index([entity])
  @@index([createdAt])
}